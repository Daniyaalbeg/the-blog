---

---

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>svg-break-apart</title>
	<style>
		body {
			background: white;
			color: #333;
			display: flex;
			font-family: Verdana, Arial, sans-serif;
		}
		img {
			height: 256px;
			width: 256px;
		}
		.col {
			width: 50%;
		}
	</style>
	<!-- <script></script> -->
</head>
<body>

	<div class="col left">
		<h2><a href="http://game-icons.net/lorc/originals/falling-blob.html">Original SVG</a></h2>
		<p>Composed of two paths: a black background square and a white drawing.</p>

		<!-- <svg id="original" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;">
			<path class="bg" fill="#000" d="M0 0h512v512H0z"></path>
			<path class="fg" fill="#fff" d="M227.54 25.87l128.997 177.28-219.59-169.19L259.07 198.92 20.78 26.128h-.005l180.06 232.19L35.878 129.186l169.19 225.433L20.17 219.052l210.703 228.224c59.994 56.81 154.88 55.822 213.664-2.963 58.782-58.783 59.77-153.668 2.962-213.664L227.54 25.87zm128.448 222.855c27.394 0 54.786 10.45 75.686 31.35 41.8 41.8 41.8 109.574 0 151.374s-109.573 41.8-151.373 0c-41.8-41.802-41.8-109.575 0-151.376 20.9-20.9 48.295-31.35 75.688-31.35zm-6.734 20.734c-17.067.057-36.98 7.253-52.576 20.872-13.134 11.468-20.463 25.015-22.217 36.897-1.753 11.88 1.438 21.776 10.216 29.11 17.555 14.667 55.232 11.185 81.5-11.752 13.134-11.47 20.462-25.015 22.217-36.897 1.754-11.88-1.438-21.776-10.215-29.11-7.132-5.96-17.247-9.16-28.924-9.12zm47.572 124.368c-8.597.03-19.063 3.706-27.14 10.65-6.803 5.848-10.36 12.6-11.172 18.01-.812 5.41.45 9.185 4.314 12.364 7.73 6.357 27.337 5.207 40.942-6.49 6.802-5.846 10.36-12.597 11.17-18.008.813-5.412-.45-9.187-4.313-12.366-3.14-2.582-7.918-4.18-13.8-4.16z"></path>
		</svg> -->
    <svg width="15" id="original" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path class="fg" d="M7.5 0C7.77614 0 8 0.223858 8 0.5V2.5C8 2.77614 7.77614 3 7.5 3C7.22386 3 7 2.77614 7 2.5V0.5C7 0.223858 7.22386 0 7.5 0ZM2.1967 2.1967C2.39196 2.00144 2.70854 2.00144 2.90381 2.1967L4.31802 3.61091C4.51328 3.80617 4.51328 4.12276 4.31802 4.31802C4.12276 4.51328 3.80617 4.51328 3.61091 4.31802L2.1967 2.90381C2.00144 2.70854 2.00144 2.39196 2.1967 2.1967ZM0.5 7C0.223858 7 0 7.22386 0 7.5C0 7.77614 0.223858 8 0.5 8H2.5C2.77614 8 3 7.77614 3 7.5C3 7.22386 2.77614 7 2.5 7H0.5ZM2.1967 12.8033C2.00144 12.608 2.00144 12.2915 2.1967 12.0962L3.61091 10.682C3.80617 10.4867 4.12276 10.4867 4.31802 10.682C4.51328 10.8772 4.51328 11.1938 4.31802 11.3891L2.90381 12.8033C2.70854 12.9986 2.39196 12.9986 2.1967 12.8033ZM12.5 7C12.2239 7 12 7.22386 12 7.5C12 7.77614 12.2239 8 12.5 8H14.5C14.7761 8 15 7.77614 15 7.5C15 7.22386 14.7761 7 14.5 7H12.5ZM10.682 4.31802C10.4867 4.12276 10.4867 3.80617 10.682 3.61091L12.0962 2.1967C12.2915 2.00144 12.608 2.00144 12.8033 2.1967C12.9986 2.39196 12.9986 2.70854 12.8033 2.90381L11.3891 4.31802C11.1938 4.51328 10.8772 4.51328 10.682 4.31802ZM8 12.5C8 12.2239 7.77614 12 7.5 12C7.22386 12 7 12.2239 7 12.5V14.5C7 14.7761 7.22386 15 7.5 15C7.77614 15 8 14.7761 8 14.5V12.5ZM10.682 10.682C10.8772 10.4867 11.1938 10.4867 11.3891 10.682L12.8033 12.0962C12.9986 12.2915 12.9986 12.608 12.8033 12.8033C12.608 12.9986 12.2915 12.9986 12.0962 12.8033L10.682 11.3891C10.4867 11.1938 10.4867 10.8772 10.682 10.682ZM5.5 7.5C5.5 6.39543 6.39543 5.5 7.5 5.5C8.60457 5.5 9.5 6.39543 9.5 7.5C9.5 8.60457 8.60457 9.5 7.5 9.5C6.39543 9.5 5.5 8.60457 5.5 7.5ZM7.5 4.5C5.84315 4.5 4.5 5.84315 4.5 7.5C4.5 9.15685 5.84315 10.5 7.5 10.5C9.15685 10.5 10.5 9.15685 10.5 7.5C10.5 5.84315 9.15685 4.5 7.5 4.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
		<!-- <svg id="original" xmlns="http://www.w3.org/2000/svg" width="15" height="15" fill="none">
			<path class="fg" fill="currentColor" fill-rule="evenodd" d="M2.9.5a.4.4 0 0 0-.8 0v.6h-.6a.4.4 0 1 0 0 .8h.6v.6a.4.4 0 1 0 .8 0v-.6h.6a.4.4 0 0 0 0-.8h-.6V.5Zm3 3a.4.4 0 1 0-.8 0v.6h-.6a.4.4 0 1 0 0 .8h.6v.6a.4.4 0 1 0 .8 0v-.6h.6a.4.4 0 0 0 0-.8h-.6v-.6Zm-4 3a.4.4 0 1 0-.8 0v.6H.5a.4.4 0 1 0 0 .8h.6v.6a.4.4 0 0 0 .8 0v-.6h.6a.4.4 0 0 0 0-.8h-.6v-.6ZM8.544.982l-.298-.04c-.213-.024-.34.224-.217.4A6.57 6.57 0 0 1 9.203 5.1a6.602 6.602 0 0 1-6.243 6.59c-.214.012-.333.264-.183.417.069.07.138.139.21.206l.072.066.26.226.188.148.121.09.187.131.176.115c.12.076.244.149.37.217l.264.135.26.12.303.122.244.086a6.568 6.568 0 0 0 1.103.26l.317.04.267.02a6.6 6.6 0 0 0 6.943-7.328l-.037-.277a6.557 6.557 0 0 0-.384-1.415l-.113-.268-.077-.166-.074-.148a6.602 6.602 0 0 0-.546-.883l-.153-.2-.199-.24-.163-.18-.12-.124-.16-.158-.223-.2-.32-.26-.245-.177-.292-.19-.321-.186-.328-.165-.113-.052-.24-.101-.276-.104-.252-.082-.325-.09-.265-.06-.292-.053Zm1.86 4.318a7.578 7.578 0 0 0-.572-2.894 5.601 5.601 0 1 1-4.748 10.146 7.61 7.61 0 0 0 3.66-2.51.749.749 0 0 0 1.355-.442.75.75 0 0 0-.584-.732c.062-.116.122-.235.178-.355A1.25 1.25 0 1 0 10.35 6.2c.034-.295.052-.595.052-.9Z" clip-rule="evenodd"/>
		</svg> -->
	</div>

	<div class="col right">
		<h2>Broken-apart SVG</h2>
		<p>The foreground path has been automatically broken apart in several paths with random colors.</p>
	</div>

	<script>

// @info
//   Polyfill for SVG 2 getPathData() and setPathData() methods. Based on:
//   - SVGPathSeg polyfill by Philip Rogers (MIT License)
//     https://github.com/progers/pathseg
//   - SVGPathNormalizer by Tadahisa Motooka (MIT License)
//     https://github.com/motooka/SVGPathNormalizer/tree/master/src
//   - arcToCubicCurves() by Dmitry Baranovskiy (MIT License)
//     https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/raphael.core.js#L1837
// @author
//   JarosÅ‚aw Foksa
// @license
//   MIT License
if (!SVGPathElement.prototype.getPathData || !SVGPathElement.prototype.setPathData) {
  let commandsMap = {
    "Z":"Z", "M":"M", "L":"L", "C":"C", "Q":"Q", "A":"A", "H":"H", "V":"V", "S":"S", "T":"T",
    "z":"Z", "m":"m", "l":"l", "c":"c", "q":"q", "a":"a", "h":"h", "v":"v", "s":"s", "t":"t"
  };

  class Source {
    constructor(string) {
      this._string = string;
      this._currentIndex = 0;
      this._endIndex = this._string.length;
      this._prevCommand = null;

      this._skipOptionalSpaces();
    }

    parseSegment() {
      let char = this._string[this._currentIndex];
      let command = commandsMap[char] ? commandsMap[char] : null;

      if (command === null) {
        if (this._prevCommand === null) {
          return null;
        }

        if (
          (char === "+" || char === "-" || char === "." || (char >= "0" && char <= "9")) && this._prevCommand !== "Z"
        ) {
          if (this._prevCommand === "M") {
            command = "L";
          }
          else if (this._prevCommand === "m") {
            command = "l";
          }
          else {
            command = this._prevCommand;
          }
        }
        else {
          command = null;
        }

        if (command === null) {
          return null;
        }
      }
      else {
        this._currentIndex += 1;
      }

      this._prevCommand = command;

      let values = null;
      let cmd = command.toUpperCase();

      if (cmd === "H" || cmd === "V") {
        values = [this._parseNumber()];
      }
      else if (cmd === "M" || cmd === "L" || cmd === "T") {
        values = [this._parseNumber(), this._parseNumber()];
      }
      else if (cmd === "S" || cmd === "Q") {
        values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];
      }
      else if (cmd === "C") {
        values = [
          this._parseNumber(),
          this._parseNumber(),
          this._parseNumber(),
          this._parseNumber(),
          this._parseNumber(),
          this._parseNumber()
        ];
      }
      else if (cmd === "A") {
        values = [
          this._parseNumber(),
          this._parseNumber(),
          this._parseNumber(),
          this._parseArcFlag(),
          this._parseArcFlag(),
          this._parseNumber(),
          this._parseNumber()
        ];
      }
      else if (cmd === "Z") {
        this._skipOptionalSpaces();
        values = [];
      }

      if (values === null || values.indexOf(null) >= 0) {
        return null;
      }
      else {
        return {type: command, values: values};
      }
    }

    hasMoreData() {
      return this._currentIndex < this._endIndex;
    }

    peekSegmentType() {
      let char = this._string[this._currentIndex];
      return commandsMap[char] ? commandsMap[char] : null;
    }

    initialCommandIsMoveTo() {
      if (!this.hasMoreData()) {
        return true;
      }

      let command = this.peekSegmentType();
      return command === "M" || command === "m";
    }

    _isCurrentSpace() {
      let char = this._string[this._currentIndex];
      return char <= " " && (char === " " || char === "\n" || char === "\t" || char === "\r" || char === "\f");
    }

    _skipOptionalSpaces() {
      while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {
        this._currentIndex += 1;
      }

      return this._currentIndex < this._endIndex;
    }

    _skipOptionalSpacesOrDelimiter() {
      if (
        this._currentIndex < this._endIndex &&
        !this._isCurrentSpace() &&
        this._string[this._currentIndex] !== ","
      ) {
        return false;
      }

      if (this._skipOptionalSpaces()) {
        if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === ",") {
          this._currentIndex += 1;
          this._skipOptionalSpaces();
        }
      }
      return this._currentIndex < this._endIndex;
    }

    _parseNumber() {
      let exponent = 0;
      let integer = 0;
      let frac = 1;
      let decimal = 0;
      let sign = 1;
      let expsign = 1;
      let startIndex = this._currentIndex;

      this._skipOptionalSpaces();

      if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === "+") {
        this._currentIndex += 1;
      }
      else if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === "-") {
        this._currentIndex += 1;
        sign = -1;
      }

      if (
        this._currentIndex === this._endIndex ||
        (
          (this._string[this._currentIndex] < "0" || this._string[this._currentIndex] > "9") &&
          this._string[this._currentIndex] !== "."
        )
      ) {
        return null;
      }

      let startIntPartIndex = this._currentIndex;

      while (
        this._currentIndex < this._endIndex &&
        this._string[this._currentIndex] >= "0" &&
        this._string[this._currentIndex] <= "9"
      ) {
        this._currentIndex += 1;
      }

      if (this._currentIndex !== startIntPartIndex) {
        let scanIntPartIndex = this._currentIndex - 1;
        let multiplier = 1;

        while (scanIntPartIndex >= startIntPartIndex) {
          integer += multiplier * (this._string[scanIntPartIndex] - "0");
          scanIntPartIndex -= 1;
          multiplier *= 10;
        }
      }

      if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === ".") {
        this._currentIndex += 1;

        if (
          this._currentIndex >= this._endIndex ||
          this._string[this._currentIndex] < "0" ||
          this._string[this._currentIndex] > "9"
        ) {
          return null;
        }

        while (
          this._currentIndex < this._endIndex &&
          this._string[this._currentIndex] >= "0" &&
          this._string[this._currentIndex] <= "9"
        ) {
          frac *= 10;
          decimal += (this._string.charAt(this._currentIndex) - "0") / frac;
          this._currentIndex += 1;
        }
      }

      if (
        this._currentIndex !== startIndex &&
        this._currentIndex + 1 < this._endIndex &&
        (this._string[this._currentIndex] === "e" || this._string[this._currentIndex] === "E") &&
        (this._string[this._currentIndex + 1] !== "x" && this._string[this._currentIndex + 1] !== "m")
      ) {
        this._currentIndex += 1;

        if (this._string[this._currentIndex] === "+") {
          this._currentIndex += 1;
        }
        else if (this._string[this._currentIndex] === "-") {
          this._currentIndex += 1;
          expsign = -1;
        }

        if (
          this._currentIndex >= this._endIndex ||
          this._string[this._currentIndex] < "0" ||
          this._string[this._currentIndex] > "9"
        ) {
          return null;
        }

        while (
          this._currentIndex < this._endIndex &&
          this._string[this._currentIndex] >= "0" &&
          this._string[this._currentIndex] <= "9"
        ) {
          exponent *= 10;
          exponent += (this._string[this._currentIndex] - "0");
          this._currentIndex += 1;
        }
      }

      let number = integer + decimal;
      number *= sign;

      if (exponent) {
        number *= Math.pow(10, expsign * exponent);
      }

      if (startIndex === this._currentIndex) {
        return null;
      }

      this._skipOptionalSpacesOrDelimiter();

      return number;
    }

    _parseArcFlag() {
      if (this._currentIndex >= this._endIndex) {
        return null;
      }

      let flag = null;
      let flagChar = this._string[this._currentIndex];

      this._currentIndex += 1;

      if (flagChar === "0") {
        flag = 0;
      }
      else if (flagChar === "1") {
        flag = 1;
      }
      else {
        return null;
      }

      this._skipOptionalSpacesOrDelimiter();
      return flag;
    }
  }

  let parsePathDataString = (string) => {
    if (!string || string.length === 0) return [];

    let source = new Source(string);
    let pathData = [];

    if (source.initialCommandIsMoveTo()) {
      while (source.hasMoreData()) {
        let pathSeg = source.parseSegment();

        if (pathSeg === null) {
          break;
        }
        else {
          pathData.push(pathSeg);
        }
      }
    }

    return pathData;
  }

  let setAttribute = SVGPathElement.prototype.setAttribute;
  let removeAttribute = SVGPathElement.prototype.removeAttribute;

  let $cachedPathData = Symbol();
  let $cachedNormalizedPathData = Symbol();

  // @info
  //   Get an array of corresponding cubic bezier curve parameters for given arc curve paramters.
  let arcToCubicCurves = (x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, _recursive) => {
    let degToRad = (degrees) => {
      return (Math.PI * degrees) / 180;
    };

    let rotate = (x, y, angleRad) => {
      let X = x * Math.cos(angleRad) - y * Math.sin(angleRad);
      let Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);
      return {x: X, y: Y};
    };

    let angleRad = degToRad(angle);
    let params = [];
    let f1, f2, cx, cy;

    if (_recursive) {
      f1 = _recursive[0];
      f2 = _recursive[1];
      cx = _recursive[2];
      cy = _recursive[3];
    }
    else {
      let p1 = rotate(x1, y1, -angleRad);
      x1 = p1.x;
      y1 = p1.y;

      let p2 = rotate(x2, y2, -angleRad);
      x2 = p2.x;
      y2 = p2.y;

      let x = (x1 - x2) / 2;
      let y = (y1 - y2) / 2;
      let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);

      if (h > 1) {
        h = Math.sqrt(h);
        r1 = h * r1;
        r2 = h * r2;
      }

      let sign;

      if (largeArcFlag === sweepFlag) {
        sign = -1;
      }
      else {
        sign = 1;
      }

      let r1Pow = r1 * r1;
      let r2Pow = r2 * r2;

      let left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;
      let right = r1Pow * y * y + r2Pow * x * x;

      let k = sign * Math.sqrt(Math.abs(left/right));

      cx = k * r1 * y / r2 + (x1 + x2) / 2;
      cy = k * -r2 * x / r1 + (y1 + y2) / 2;

      f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));
      f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));

      if (x1 < cx) {
        f1 = Math.PI - f1;
      }
      if (x2 < cx) {
        f2 = Math.PI - f2;
      }

      if (f1 < 0) {
        f1 = Math.PI * 2 + f1;
      }
      if (f2 < 0) {
        f2 = Math.PI * 2 + f2;
      }

      if (sweepFlag && f1 > f2) {
        f1 = f1 - Math.PI * 2;
      }
      if (!sweepFlag && f2 > f1) {
        f2 = f2 - Math.PI * 2;
      }
    }

    let df = f2 - f1;

    if (Math.abs(df) > (Math.PI * 120 / 180)) {
      let f2old = f2;
      let x2old = x2;
      let y2old = y2;

      if (sweepFlag && f2 > f1) {
        f2 = f1 + (Math.PI * 120 / 180) * (1);
      }
      else {
        f2 = f1 + (Math.PI * 120 / 180) * (-1);
      }

      x2 = cx + r1 * Math.cos(f2);
      y2 = cy + r2 * Math.sin(f2);
      params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);
    }

    df = f2 - f1;

    let c1 = Math.cos(f1);
    let s1 = Math.sin(f1);
    let c2 = Math.cos(f2);
    let s2 = Math.sin(f2);
    let t = Math.tan(df / 4);
    let hx = 4 / 3 * r1 * t;
    let hy = 4 / 3 * r2 * t;

    let m1 = [x1, y1];
    let m2 = [x1 + hx * s1, y1 - hy * c1];
    let m3 = [x2 + hx * s2, y2 - hy * c2];
    let m4 = [x2, y2];

    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];

    if (_recursive) {
      return [m2, m3, m4].concat(params);
    }
    else {
      params = [m2, m3, m4].concat(params).join().split(",");

      let curves = [];
      let curveParams = [];

      params.forEach( function(param, i) {
        if (i % 2) {
          curveParams.push(rotate(params[i - 1], params[i], angleRad).y);
        }
        else {
          curveParams.push(rotate(params[i], params[i + 1], angleRad).x);
        }

        if (curveParams.length === 6) {
          curves.push(curveParams);
          curveParams = [];
        }
      });

      return curves;
    }
  };

  let clonePathData = (pathData) => {
    return pathData.map((seg) => {
      return {type: seg.type, values: [...seg.values]}
    });
  };

  // @info
  //   Takes any path data, returns path data that consists only from absolute commands.
  let absolutizePathData = (pathData) => {
    let absolutizedPathData = [];

    let currentX = null;
    let currentY = null;

    let subpathX = null;
    let subpathY = null;

    for (let seg of pathData) {
      let type = seg.type;

      if (type === "M") {
        let [x, y] = seg.values;

        absolutizedPathData.push({type: "M", values: [x, y]});

        subpathX = x;
        subpathY = y;

        currentX = x;
        currentY = y;
      }

      else if (type === "m") {
        let [x, y] = seg.values;

        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "M", values: [x, y]});

        subpathX = x;
        subpathY = y;

        currentX = x;
        currentY = y;
      }

      else if (type === "L") {
        let [x, y] = seg.values;

        absolutizedPathData.push({type: "L", values: [x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "l") {
        let [x, y] = seg.values;

        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "L", values: [x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "C") {
        let [x1, y1, x2, y2, x, y] = seg.values;

        absolutizedPathData.push({type: "C", values: [x1, y1, x2, y2, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "c") {
        let [x1, y1, x2, y2, x, y] = seg.values;

        x1 += currentX;
        y1 += currentY;
        x2 += currentX;
        y2 += currentY;
        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "C", values: [x1, y1, x2, y2, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "Q") {
        let [x1, y1, x, y] = seg.values;

        absolutizedPathData.push({type: "Q", values: [x1, y1, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "q") {
        let [x1, y1, x, y] = seg.values;

        x1 += currentX;
        y1 += currentY;
        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "Q", values: [x1, y1, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "A") {
        let [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y] = seg.values;

        absolutizedPathData.push({
          type: "A",
          values: [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y]
        });

        currentX = x;
        currentY = y;
      }

      else if (type === "a") {
        let [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y] = seg.values;

        x += currentX;
        y += currentY;

        absolutizedPathData.push({
          type: "A",
          values: [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y]
        });

        currentX = x;
        currentY = y;
      }

      else if (type === "H") {
        let [x] = seg.values;
        absolutizedPathData.push({type: "H", values: [x]});
        currentX = x;
      }

      else if (type === "h") {
        let [x] = seg.values;
        x += currentX;

        absolutizedPathData.push({type: "H", values: [x]});
        currentX = x;
      }

      else if (type === "V") {
        let [y] = seg.values;

        absolutizedPathData.push({type: "V", values: [y]});
        currentY = y;
      }

      else if (type === "v") {
        let [y] = seg.values;
        y += currentY;

        absolutizedPathData.push({type: "V", values: [y]});
        currentY = y;
      }

      else if (type === "S") {
        let [x2, y2, x, y] = seg.values;

        absolutizedPathData.push({type: "S", values: [x2, y2, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "s") {
        let [x2, y2, x, y] = seg.values;

        x2 += currentX;
        y2 += currentY;
        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "S", values: [x2, y2, x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "T") {
        let [x, y] = seg.values;

        absolutizedPathData.push({type: "T", values: [x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "t") {
        let [x, y] = seg.values;

        x += currentX;
        y += currentY;

        absolutizedPathData.push({type: "T", values: [x, y]});

        currentX = x;
        currentY = y;
      }

      else if (type === "Z" || type === "z") {
        absolutizedPathData.push({type: "Z", values: []});

        currentX = subpathX;
        currentY = subpathY;
      }
    }

    return absolutizedPathData;
  };

  // @info
  //   Takes path data that consists only from absolute commands, returns path data that consists only from
  //   "M", "L", "C" and "Z" commands.
  let reducePathData = (pathData) => {
    let reducedPathData = [];
    let lastType = null;

    let lastControlX = null;
    let lastControlY = null;

    let currentX = null;
    let currentY = null;

    let subpathX = null;
    let subpathY = null;

    for (let seg of pathData) {
      if (seg.type === "M") {
        let [x, y] = seg.values;

        reducedPathData.push({type: "M", values: [x, y]});

        subpathX = x;
        subpathY = y;

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "C") {
        let [x1, y1, x2, y2, x, y] = seg.values;

        reducedPathData.push({type: "C", values: [x1, y1, x2, y2, x, y]});

        lastControlX = x2;
        lastControlY = y2;

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "L") {
        let [x, y] = seg.values;

        reducedPathData.push({type: "L", values: [x, y]});

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "H") {
        let [x] = seg.values;

        reducedPathData.push({type: "L", values: [x, currentY]});

        currentX = x;
      }

      else if (seg.type === "V") {
        let [y] = seg.values;

        reducedPathData.push({type: "L", values: [currentX, y]});

        currentY = y;
      }

      else if (seg.type === "S") {
        let [x2, y2, x, y] = seg.values;
        let cx1, cy1;

        if (lastType === "C" || lastType === "S") {
          cx1 = currentX + (currentX - lastControlX);
          cy1 = currentY + (currentY - lastControlY);
        }
        else {
          cx1 = currentX;
          cy1 = currentY;
        }

        reducedPathData.push({type: "C", values: [cx1, cy1, x2, y2, x, y]});

        lastControlX = x2;
        lastControlY = y2;

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "T") {
        let [x, y] = seg.values;
        let x1, y1;

        if (lastType === "Q" || lastType === "T") {
          x1 = currentX + (currentX - lastControlX);
          y1 = currentY + (currentY - lastControlY);
        }
        else {
          x1 = currentX;
          y1 = currentY;
        }

        let cx1 = currentX + 2 * (x1 - currentX) / 3;
        let cy1 = currentY + 2 * (y1 - currentY) / 3;
        let cx2 = x + 2 * (x1 - x) / 3;
        let cy2 = y + 2 * (y1 - y) / 3;

        reducedPathData.push({type: "C", values: [cx1, cy1, cx2, cy2, x, y]});

        lastControlX = x1;
        lastControlY = y1;

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "Q") {
        let [x1, y1, x, y] = seg.values;
        let cx1 = currentX + 2 * (x1 - currentX) / 3;
        let cy1 = currentY + 2 * (y1 - currentY) / 3;
        let cx2 = x + 2 * (x1 - x) / 3;
        let cy2 = y + 2 * (y1 - y) / 3;

        reducedPathData.push({type: "C", values: [cx1, cy1, cx2, cy2, x, y]});

        lastControlX = x1;
        lastControlY = y1;

        currentX = x;
        currentY = y;
      }

      else if (seg.type === "A") {
        let [r1, r2, angle, largeArcFlag, sweepFlag, x, y] = seg.values;

        if (r1 === 0 || r2 === 0) {
          reducedPathData.push({type: "C", values: [currentX, currentY, x, y, x, y]});

          currentX = x;
          currentY = y;
        }
        else {
          if (currentX !== x || currentY !== y) {
            let curves = arcToCubicCurves(currentX, currentY, x, y, r1, r2, angle, largeArcFlag, sweepFlag);

            curves.forEach( function(curve) {
              reducedPathData.push({type: "C", values: curve});

              currentX = x;
              currentY = y;
            });
          }
        }
      }

      else if (seg.type === "Z") {
        reducedPathData.push(seg);

        currentX = subpathX;
        currentY = subpathY;
      }

      lastType = seg.type;
    }

    return reducedPathData;
  };

  SVGPathElement.prototype.setAttribute = function(name, value) {
    if (name === "d") {
      this[$cachedPathData] = null;
      this[$cachedNormalizedPathData] = null;
    }

    setAttribute.call(this, name, value);
  };

  SVGPathElement.prototype.removeAttribute = function(name, value) {
    if (name === "d") {
      this[$cachedPathData] = null;
      this[$cachedNormalizedPathData] = null;
    }

    removeAttribute.call(this, name);
  };

  SVGPathElement.prototype.getPathData = function(options) {
    if (options && options.normalize) {
      if (this[$cachedNormalizedPathData]) {
        return clonePathData(this[$cachedNormalizedPathData]);
      }
      else {
        let pathData;

        if (this[$cachedPathData]) {
          pathData = clonePathData(this[$cachedPathData]);
        }
        else {
          pathData = parsePathDataString(this.getAttribute("d") || "");
          this[$cachedPathData] = clonePathData(pathData);
        }

        let normalizedPathData = reducePathData(absolutizePathData(pathData));
        this[$cachedNormalizedPathData] = clonePathData(normalizedPathData);
        return normalizedPathData;
      }
    }
    else {
      if (this[$cachedPathData]) {
        return clonePathData(this[$cachedPathData]);
      }
      else {
        let pathData = parsePathDataString(this.getAttribute("d") || "");
        this[$cachedPathData] = clonePathData(pathData);
        return pathData;
      }
    }
  };

  SVGPathElement.prototype.setPathData = function(pathData) {
    if (pathData.length === 0) {
      this.removeAttribute("d");
    }
    else {
      let d = "";

      for (let i = 0, l = pathData.length; i < l; i += 1) {
        let seg = pathData[i];

        if (i > 0) {
          d += " ";
        }

        d += seg.type;

        if (seg.values && seg.values.length > 0) {
          d += " " + seg.values.join(" ");
        }
      }

      this.setAttribute("d", d);
    }
  };

  SVGRectElement.prototype.getPathData = function(options) {
    let x = this.x.baseVal.value;
    let y = this.y.baseVal.value;
    let width = this.width.baseVal.value;
    let height = this.height.baseVal.value;
    let rx = this.hasAttribute("rx") ? this.rx.baseVal.value : this.ry.baseVal.value;
    let ry = this.hasAttribute("ry") ? this.ry.baseVal.value : this.rx.baseVal.value;

    if (rx > width / 2) {
      rx = width / 2;
    }

    if (ry > height / 2) {
      ry = height / 2;
    }

    let pathData = [
      {type: "M", values: [x+rx, y]},
      {type: "H", values: [x+width-rx]},
      {type: "A", values: [rx, ry, 0, 0, 1, x+width, y+ry]},
      {type: "V", values: [y+height-ry]},
      {type: "A", values: [rx, ry, 0, 0, 1, x+width-rx, y+height]},
      {type: "H", values: [x+rx]},
      {type: "A", values: [rx, ry, 0, 0, 1, x, y+height-ry]},
      {type: "V", values: [y+ry]},
      {type: "A", values: [rx, ry, 0, 0, 1, x+rx, y]},
      {type: "Z", values: []}
    ];

    // Get rid of redundant "A" segs when either rx or ry is 0
    pathData = pathData.filter(s => s.type === "A" && (s.values[0] === 0 || s.values[1] === 0) ? false : true);

    if (options && options.normalize === true) {
      pathData = reducePathData(pathData);
    }

    return pathData;
  };

  SVGCircleElement.prototype.getPathData = function(options) {
    let cx = this.cx.baseVal.value;
    let cy = this.cy.baseVal.value;
    let r = this.r.baseVal.value;

    let pathData = [
      { type: "M",  values: [cx + r, cy] },
      { type: "A",  values: [r, r, 0, 0, 1, cx, cy+r] },
      { type: "A",  values: [r, r, 0, 0, 1, cx-r, cy] },
      { type: "A",  values: [r, r, 0, 0, 1, cx, cy-r] },
      { type: "A",  values: [r, r, 0, 0, 1, cx+r, cy] },
      { type: "Z",  values: [] }
    ];

    if (options && options.normalize === true) {
      pathData = reducePathData(pathData);
    }

    return pathData;
  };

  SVGEllipseElement.prototype.getPathData = function(options) {
    let cx = this.cx.baseVal.value;
    let cy = this.cy.baseVal.value;
    let rx = this.rx.baseVal.value;
    let ry = this.ry.baseVal.value;

    let pathData = [
      { type: "M",  values: [cx + rx, cy] },
      { type: "A",  values: [rx, ry, 0, 0, 1, cx, cy+ry] },
      { type: "A",  values: [rx, ry, 0, 0, 1, cx-rx, cy] },
      { type: "A",  values: [rx, ry, 0, 0, 1, cx, cy-ry] },
      { type: "A",  values: [rx, ry, 0, 0, 1, cx+rx, cy] },
      { type: "Z",  values: [] }
    ];

    if (options && options.normalize === true) {
      pathData = reducePathData(pathData);
    }

    return pathData;
  };

  SVGLineElement.prototype.getPathData = function() {
    return [
      { type: "M", values: [this.x1.baseVal.value, this.y1.baseVal.value] },
      { type: "L", values: [this.x2.baseVal.value, this.y2.baseVal.value] }
    ];
  };

  SVGPolylineElement.prototype.getPathData = function() {
    let pathData = [];

    for (let i = 0; i < this.points.numberOfItems; i += 1) {
      let point = this.points.getItem(i);

      pathData.push({
        type: (i === 0 ? "M" : "L"),
        values: [point.x, point.y]
      });
    }

    return pathData;
  };

  SVGPolygonElement.prototype.getPathData = function() {
    let pathData = [];

    for (let i = 0; i < this.points.numberOfItems; i += 1) {
      let point = this.points.getItem(i);

      pathData.push({
        type: (i === 0 ? "M" : "L"),
        values: [point.x, point.y]
      });
    }

    pathData.push({
      type: "Z",
      values: []
    });

    return pathData;
  };
}


		(() => {
			// split the fg pathData on each M segment
			// polyfill is needed for now (Feb 2017)

			const randomColor = () => '#'+('00000'+(Math.random()*(1<<24)|0).toString(16)).slice(-6)

			const ba = document.getElementById('original').cloneNode(true)
			document.querySelector('.right').appendChild(ba)
			const fg = ba.querySelector('.fg')

			// normalize should be used to get back absolute segments
			const pathsDatas = fg.getPathData({ normalize: true }).reduce((acc, seg) => {
				let pathData = seg.type === 'M' ? [] : acc.pop()
				seg.values = seg.values.map(v => Math.round(v * 1000) / 1000)
				pathData.push(seg)
				acc.push(pathData)
				return acc
			}, [])

			fg.remove()

			pathsDatas.forEach((d) => {
				const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
				path.setPathData(d)
				path.setAttribute('fill', randomColor())
				ba.appendChild(path)
			})
		})()
	</script>
</body>
</html>